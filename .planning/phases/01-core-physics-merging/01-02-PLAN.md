---
phase: 01-core-physics-merging
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - scenes/fruit/fruit.tscn
  - scenes/fruit/fruit.gd
  - scripts/components/merge_manager.gd
  - scripts/components/drop_controller.gd
  - scenes/game/game.tscn
  - scenes/game/game.gd
autonomous: true

must_haves:
  truths:
    - "Player can position a fruit horizontally by moving the mouse above the bucket"
    - "Clicking drops the fruit which falls under gravity into the bucket"
    - "Two identical fruits touching each other merge into the next tier at the contact midpoint"
    - "Two watermelons merging vanish with no crash or duplicate spawn"
    - "Only tiers 1-5 appear as drops"
    - "A faint vertical drop guide line shows where the fruit will land"
  artifacts:
    - path: "scenes/fruit/fruit.tscn"
      provides: "Reusable fruit scene (RigidBody2D)"
      contains: "CircleShape2D"
    - path: "scenes/fruit/fruit.gd"
      provides: "Fruit behavior and collision handler"
      contains: "class_name Fruit"
    - path: "scripts/components/merge_manager.gd"
      provides: "Merge gatekeeper preventing double-merge"
      contains: "request_merge"
    - path: "scripts/components/drop_controller.gd"
      provides: "Input handling and fruit spawning"
      contains: "_drop_fruit"
    - path: "scenes/game/game.tscn"
      provides: "Root game scene assembling all components"
    - path: "scenes/game/game.gd"
      provides: "Game loop orchestration"
  key_links:
    - from: "scenes/fruit/fruit.gd"
      to: "scripts/components/merge_manager.gd"
      via: "collision callback requests merge"
      pattern: "MergeManager.*request_merge"
    - from: "scripts/components/merge_manager.gd"
      to: "scripts/autoloads/event_bus.gd"
      via: "emits fruit_merged signal after merge"
      pattern: "EventBus.fruit_merged.emit"
    - from: "scripts/components/drop_controller.gd"
      to: "resources/fruit_data/fruit_data.gd"
      via: "reads FruitData to initialize fruits"
      pattern: "initialize.*FruitData"
    - from: "scenes/fruit/fruit.gd"
      to: "resources/fruit_data/fruit_data.gd"
      via: "configures from FruitData resource"
      pattern: "fruit_data"
---

<objective>
Build the core fruit gameplay: a reusable fruit scene driven by FruitData resources, the MergeManager gatekeeper that prevents double-merge bugs, and the DropController that lets players position and drop fruits with mouse input. Wire these into a game scene where players can actually drop and merge fruits.

Purpose: This is the core gameplay loop. Without fruit spawning, dropping, and merging, nothing else in Phase 1 matters.
Output: A playable game scene where fruits drop, collide, stack, and merge correctly.
</objective>

<execution_context>
@C:/Users/zycro/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/zycro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-physics-merging/01-RESEARCH.md
@.planning/phases/01-core-physics-merging/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reusable fruit scene and MergeManager gatekeeper</name>
  <files>
    scenes/fruit/fruit.tscn
    scenes/fruit/fruit.gd
    scripts/components/merge_manager.gd
  </files>
  <action>
    **fruit.tscn:**
    Create a single reusable fruit scene with this structure:
    ```
    Fruit (RigidBody2D) -- collision layer 1 (Fruits), mask layers 1+2 (Fruits + Container)
      +-- Sprite2D -- texture set at runtime from FruitData
      +-- CollisionShape2D -- CircleShape2D, radius set at runtime from FruitData
    ```

    RigidBody2D settings:
    - contact_monitor = true
    - max_contacts_reported = 4
    - continuous_cd = CCD_MODE_CAST_RAY (prevent wall tunneling)
    - can_sleep = true
    - gravity_scale = 1.0
    - collision layer = 1 (Fruits), collision mask = 1 + 2 (Fruits + Container)
    - physics_material_override = preload fruit_physics.tres (friction=0.6, bounce=0.15)

    Connect the body_entered signal to fruit.gd._on_body_entered.

    **fruit.gd:**
    Create script with class_name Fruit, extends RigidBody2D:

    Properties:
    - `var fruit_data: FruitData` -- set via initialize()
    - `var merging: bool = false` -- prevents double-merge
    - `var is_dropping: bool = false` -- true while player positions this fruit
    - `var merge_grace: bool = false` -- true briefly after spawning from merge

    `func initialize(data: FruitData) -> void`:
    - Store fruit_data = data
    - Set $Sprite2D.texture = data.sprite
    - Create NEW CircleShape2D instance (NEVER share shapes): `var shape := CircleShape2D.new(); shape.radius = data.radius; $CollisionShape2D.shape = shape`
    - Set mass = data.mass_override
    - Scale sprite to match radius: calculate scale_factor = data.radius / (texture_width / 2.0), set $Sprite2D.scale = Vector2(scale_factor, scale_factor)
    - Modulate the sprite with data.color for visual distinction (since we use placeholder textures)

    `func _on_body_entered(body: Node) -> void`:
    - Guard: if not (body is Fruit) -> return
    - Guard: if merging or body.merging -> return
    - Guard: if is_dropping or body.is_dropping -> return
    - Guard: if merge_grace or body.merge_grace -> return
    - Guard: if body.fruit_data.tier != fruit_data.tier -> return
    - Deterministic tiebreaker: if get_instance_id() < body.get_instance_id() -> call merge_manager.request_merge(self, body)
    - The tiebreaker ensures only ONE of the two colliding fruits requests the merge, preventing duplicates.

    NOTE: The fruit references the MergeManager via its parent game scene (not as autoload). The fruit finds it via: `get_tree().get_first_node_in_group("merge_manager")` -- so MergeManager must be added to group "merge_manager" in the game scene.

    **merge_manager.gd:**
    Create script with class_name MergeManager, extends Node:

    Properties:
    - `var _pending_merges: Dictionary = {}` -- instance_id -> true
    - `var _fruit_scene: PackedScene = preload("res://scenes/fruit/fruit.tscn")`
    - `var _fruit_types: Array[FruitData] = []` -- loaded in _ready(), indexed by tier

    `func _ready() -> void`:
    - Load all 8 FruitData .tres files into _fruit_types array, ordered by tier (0-7)
    - Add self to group "merge_manager"

    `func request_merge(fruit_a: Fruit, fruit_b: Fruit) -> void`:
    - Get instance IDs for both fruits
    - Guard: if either ID already in _pending_merges -> return (prevents double-merge)
    - Lock both: add both IDs to _pending_merges, set merging=true on both
    - Calculate merge_pos = midpoint of both fruits' global_position
    - Get old_tier from fruit_a.fruit_data.tier
    - Calculate new_tier = old_tier + 1
    - Call _deactivate_fruit() on both fruits
    - If new_tier < _fruit_types.size(): spawn new fruit at merge_pos with merge_grace=true, start 0.5s timer to clear grace
    - If new_tier >= _fruit_types.size(): watermelon pair vanish -- no spawn (placeholder: brief flash effect later)
    - Emit EventBus.fruit_merged.emit(old_tier, new_tier, merge_pos) -- for watermelon vanish, emit with new_tier = -1 or _fruit_types.size()
    - call_deferred("_cleanup_pending", id_a, id_b) to clean up locks after physics frame

    `func _deactivate_fruit(fruit: Fruit) -> void`:
    CRITICAL: This is the safe removal pattern that prevents physics crashes.
    1. fruit.set_contact_monitor(false)
    2. fruit.freeze = true
    3. fruit.get_node("CollisionShape2D").set_deferred("disabled", true)
    4. fruit.visible = false
    5. fruit.call_deferred("queue_free")

    `func _cleanup_pending(id_a: int, id_b: int) -> void`:
    - _pending_merges.erase(id_a)
    - _pending_merges.erase(id_b)

    `func spawn_fruit(tier: int, pos: Vector2, dropping: bool = false) -> Fruit`:
    Public function for spawning fruits (used by DropController too):
    - Instantiate _fruit_scene
    - Initialize with _fruit_types[tier]
    - Add as child of the fruit container node (find via group "fruit_container")
    - Set global_position = pos
    - If dropping: set freeze=true, freeze_mode=FREEZE_MODE_KINEMATIC, is_dropping=true
    - Return the fruit instance

    IMPORTANT ANTI-PATTERNS TO AVOID:
    - Do NOT scale the RigidBody2D node. Scale only Sprite2D child and set shape.radius.
    - Do NOT call queue_free() directly. Always use _deactivate_fruit().
    - Do NOT use body_shape_entered (has duplicate-signal bug #98353). Use body_entered.
    - Do NOT share CircleShape2D instances between fruits. Always CircleShape2D.new().
  </action>
  <verify>
    1. fruit.tscn opens in editor with RigidBody2D root, Sprite2D child, CollisionShape2D child
    2. Can instantiate a fruit via code, call initialize() with a FruitData, and verify sprite/shape/mass are set
    3. MergeManager._ready() loads all 8 tiers without errors
    4. Manual test: spawn two tier-0 fruits overlapping -> request_merge called -> one tier-1 fruit appears at midpoint, both originals freed
  </verify>
  <done>
    Fruit scene exists as a single reusable RigidBody2D configured by FruitData resources. MergeManager gatekeeper prevents double-merge via instance ID locking, deactivates fruits safely (no physics crash), and spawns the next-tier fruit at the midpoint. Watermelon pairs vanish without spawning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DropController with cursor tracking, drop guide, and game scene</name>
  <files>
    scripts/components/drop_controller.gd
    scenes/game/game.tscn
    scenes/game/game.gd
  </files>
  <action>
    **drop_controller.gd:**
    Create script with class_name DropController, extends Node2D:

    Properties:
    - `var _current_fruit: Fruit = null` -- the fruit being positioned
    - `var _next_tier: int = -1` -- tier of the next fruit to drop
    - `var _can_drop: bool = true`
    - `var _drop_cooldown: float = 0.15` -- seconds between drops
    - `var _bucket_left: float` -- set from bucket geometry
    - `var _bucket_right: float` -- set from bucket geometry
    - `var _drop_y: float` -- Y position where preview fruit hovers (above bucket rim)
    - `@onready var _drop_guide: Line2D` -- vertical guide line child node
    - `@onready var _merge_manager: MergeManager` -- found via group

    `func _ready() -> void`:
    - Find bucket via group "bucket" and query drop bounds + overflow_y
    - Set _bucket_left, _bucket_right from bucket.get_drop_bounds()
    - Set _drop_y to bucket top - 80px (above the rim, room for largest droppable fruit)
    - Find MergeManager via get_tree().get_first_node_in_group("merge_manager")
    - Set up the Line2D drop guide as a child: default_color = Color(1, 1, 1, 0.15), width = 1.5
    - Call _roll_next_tier() then _spawn_preview()

    `func _unhandled_input(event: InputEvent) -> void`:
    - If event is InputEventMouseMotion and _current_fruit exists and GameManager.current_state != GameState.GAME_OVER:
      - Clamp event.position.x between _bucket_left and _bucket_right
      - Set _current_fruit.global_position.x = clamped_x
      - Set _current_fruit.global_position.y = _drop_y
      - Update drop guide: two points from (clamped_x, _drop_y) to (clamped_x, bucket_floor_y)
    - If event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.pressed and _can_drop and _current_fruit and GameManager.current_state != GameState.GAME_OVER:
      - Call _drop_fruit()

    `func _drop_fruit() -> void`:
    - _current_fruit.freeze = false (enters physics simulation -- pure gravity, zero initial velocity per discretion)
    - _current_fruit.is_dropping = false
    - EventBus.fruit_dropped.emit(_current_fruit.fruit_data.tier, _current_fruit.global_position)
    - _current_fruit = null
    - _can_drop = false
    - Hide drop guide
    - Start cooldown: await get_tree().create_timer(_drop_cooldown).timeout
    - _can_drop = true
    - _spawn_preview()

    `func _spawn_preview() -> void`:
    - Use MergeManager.spawn_fruit(_next_tier, Vector2(_last_drop_x or center, _drop_y), true) to create frozen preview
    - _current_fruit = the returned fruit
    - Show drop guide
    - _roll_next_tier()

    `func _roll_next_tier() -> void`:
    - Pick random tier from 0-4 (equal probability, only droppable tiers)
    - Store in _next_tier
    - Emit a signal or update HUD with next fruit info (EventBus or direct reference)

    The DropController also has a `_last_drop_x: float` to remember cursor position between drops (default: center of bucket).

    **game.tscn:**
    Create the root game scene that assembles everything:
    ```
    Game (Node2D)
      +-- Background (instance of background.tscn)
      +-- Bucket (instance of bucket.tscn) -- add to group "bucket"
      +-- FruitContainer (Node2D) -- add to group "fruit_container", holds all spawned fruits
      +-- MergeManager (Node, script: merge_manager.gd) -- add to group "merge_manager"
      +-- DropController (Node2D, script: drop_controller.gd)
        +-- DropGuide (Line2D) -- faint vertical guide line
    ```

    Position the Bucket centered horizontally (x=540 for a 1080-wide viewport).

    **game.gd:**
    Create script attached to Game (Node2D):
    - `func _ready()`: Set GameManager.change_state(GameState.READY), then change to DROPPING after a brief delay (0.3s) to let physics settle
    - Connect EventBus.game_over_triggered to _on_game_over
    - `func _on_game_over()`: GameManager.change_state(GameState.GAME_OVER), print "GAME OVER" (proper game-over UI comes in Phase 4)
    - Set this scene as the main scene in project.godot (run_main_scene)

    Set game.tscn as the main scene in project.godot so pressing F5/Play runs the game.
  </action>
  <verify>
    1. Press F5 in Godot editor -- game launches with kitchen background and wooden bucket visible
    2. A fruit appears above the bucket following the mouse cursor horizontally
    3. A faint vertical line extends from the fruit down into the bucket
    4. Clicking drops the fruit -- it falls under gravity into the bucket
    5. After a brief cooldown, a new preview fruit appears (random tier 1-5)
    6. Drop 5+ fruits -- they stack inside the bucket with natural physics
    7. Drop two same-tier fruits near each other -- they merge into the next tier at the midpoint
    8. No crashes, no duplicate merges, no errors in Output panel
  </verify>
  <done>
    DropController allows mouse-based fruit positioning and dropping with a faint drop guide line, 0.15s cooldown, and random tier 1-5 selection. Game scene assembles Background + Bucket + FruitContainer + MergeManager + DropController. Running the project shows a playable fruit-dropping game with working merges.
  </done>
</task>

</tasks>

<verification>
1. Running the project (F5) shows a kitchen background with a wooden bucket
2. Mouse controls fruit position above the bucket with a vertical guide line
3. Clicking drops fruits that fall under gravity and collide with walls/floor/other fruits
4. Same-tier fruit collisions produce one next-tier fruit at the midpoint
5. No double merges (drop many same-tier fruits rapidly and verify one merge per pair)
6. No crashes when many merges happen in quick succession
7. Watermelon pair vanish: manually spawn two watermelons (via debug) and verify they disappear without crash
8. Only tiers 1-5 appear as drops
9. Fruits stack without visible jitter (test with 15+ fruits)
</verification>

<success_criteria>
- Fruit scene is a single reusable RigidBody2D configured by FruitData.initialize()
- MergeManager prevents double-merge via instance ID locking
- MergeManager uses safe _deactivate_fruit pattern (no queue_free in physics callbacks)
- DropController tracks mouse position, clamps to bucket bounds, drops on click
- Drop guide line shows landing position
- 0.15s cooldown between drops
- Only tiers 0-4 appear as drops (equal random probability)
- Game scene assembles all components and is set as main scene
- Running the project produces a playable drop-merge experience
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-physics-merging/01-02-SUMMARY.md`
</output>
