---
phase: 02-scoring-chain-reactions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/components/score_manager.gd
  - scripts/autoloads/event_bus.gd
  - scripts/autoloads/game_manager.gd
  - resources/fruit_data/tier_1_blueberry.tres
  - resources/fruit_data/tier_2_grape.tres
  - resources/fruit_data/tier_3_cherry.tres
  - resources/fruit_data/tier_4_strawberry.tres
  - resources/fruit_data/tier_5_orange.tres
  - resources/fruit_data/tier_6_apple.tres
  - resources/fruit_data/tier_7_pear.tres
  - resources/fruit_data/tier_8_watermelon.tres
  - scenes/game/game.tscn
autonomous: true

must_haves:
  truths:
    - "Each merge awards points that scale exponentially with fruit tier (powers of 2)"
    - "Watermelon pair vanish awards a flat 1000-point bonus"
    - "Cascade merges (merge result triggers another merge) increment chain counter and apply accelerating multipliers"
    - "Chain counter resets when no further cascade merge occurs within the settling window"
    - "Coins are awarded when cumulative score crosses 100-point thresholds"
    - "Score threshold signals are emitted for Phase 5 shop triggers"
  artifacts:
    - path: "scripts/components/score_manager.gd"
      provides: "Scoring logic, chain tracking, coin economy"
      contains: "class_name ScoreManager"
    - path: "scripts/autoloads/event_bus.gd"
      provides: "New scoring signals"
      contains: "signal score_awarded"
    - path: "scripts/autoloads/game_manager.gd"
      provides: "Coins variable and reset"
      contains: "var coins"
    - path: "resources/fruit_data/tier_1_blueberry.tres"
      provides: "Updated score_value = 1"
    - path: "resources/fruit_data/tier_8_watermelon.tres"
      provides: "Updated score_value = 128"
  key_links:
    - from: "scripts/components/score_manager.gd"
      to: "scripts/autoloads/event_bus.gd"
      via: "EventBus.fruit_merged.connect and EventBus.score_awarded.emit"
      pattern: "fruit_merged\\.connect|score_awarded\\.emit"
    - from: "scripts/components/score_manager.gd"
      to: "scripts/autoloads/game_manager.gd"
      via: "GameManager.score += and GameManager.coins +="
      pattern: "GameManager\\.score|GameManager\\.coins"
    - from: "scenes/game/game.tscn"
      to: "scripts/components/score_manager.gd"
      via: "ScoreManager node added to game scene"
      pattern: "score_manager"
---

<objective>
Create the ScoreManager component that implements exponential scoring, cascade-based chain tracking with accelerating multipliers, and score-derived coin economy. Update FruitData resources with power-of-2 score values, add new EventBus signals for score/chain/coin events, and add coins to GameManager.

Purpose: This is the scoring "brain" -- all point calculation, chain detection, and coin awarding logic lives here. The HUD and floating popups (Plan 02) consume the signals this plan emits.
Output: ScoreManager node in game scene, updated FruitData score values, new EventBus signals, GameManager coins variable.
</objective>

<execution_context>
@/home/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/home/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-scoring-chain-reactions/02-CONTEXT.md
@.planning/phases/02-scoring-chain-reactions/02-RESEARCH.md
@.planning/phases/01-core-physics-merging/01-02-SUMMARY.md

Key existing files to read before implementing:
@scripts/autoloads/event_bus.gd
@scripts/autoloads/game_manager.gd
@scripts/components/merge_manager.gd
@scenes/game/game.tscn
@resources/fruit_data/fruit_data.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EventBus signals, GameManager coins, and update FruitData score values</name>
  <files>
    scripts/autoloads/event_bus.gd
    scripts/autoloads/game_manager.gd
    resources/fruit_data/tier_1_blueberry.tres
    resources/fruit_data/tier_2_grape.tres
    resources/fruit_data/tier_3_cherry.tres
    resources/fruit_data/tier_4_strawberry.tres
    resources/fruit_data/tier_5_orange.tres
    resources/fruit_data/tier_6_apple.tres
    resources/fruit_data/tier_7_pear.tres
    resources/fruit_data/tier_8_watermelon.tres
  </files>
  <action>
    **EventBus (event_bus.gd):** Add 4 new signals after the existing ones:
    - `signal score_awarded(points: int, position: Vector2, chain_count: int, multiplier: int)` -- emitted on every merge with calculated score
    - `signal chain_ended(chain_length: int)` -- emitted when a chain ends (no more cascading merges)
    - `signal coins_awarded(new_coins: int, total_coins: int)` -- emitted when score crosses coin thresholds
    - `signal score_threshold_reached(threshold: int)` -- emitted for Phase 5 shop triggers

    **GameManager (game_manager.gd):** Add `var coins: int = 0` alongside the existing `var score: int = 0`. Update `reset_game()` to also reset `coins = 0`.

    **FruitData .tres files:** Update the `score_value` field in each .tres file to use powers of 2:
    - tier_1_blueberry.tres: score_value = 1 (unchanged)
    - tier_2_grape.tres: score_value = 2 (was 3)
    - tier_3_cherry.tres: score_value = 4 (was 6)
    - tier_4_strawberry.tres: score_value = 8 (was 10)
    - tier_5_orange.tres: score_value = 16 (was 15)
    - tier_6_apple.tres: score_value = 32 (was 21)
    - tier_7_pear.tres: score_value = 64 (was 28)
    - tier_8_watermelon.tres: score_value = 128 (was 36)

    IMPORTANT: When editing .tres files, read each file first to get the exact format. Only change the score_value line. The .tres format uses `[resource]` section headers and `key = value` lines.
  </action>
  <verify>
    Grep event_bus.gd for all 4 new signals (score_awarded, chain_ended, coins_awarded, score_threshold_reached).
    Grep game_manager.gd for `var coins` and verify reset_game sets coins = 0.
    Grep each .tres file for the updated score_value (confirm tier_8 = 128, tier_5 = 16, etc.).
  </verify>
  <done>
    EventBus has 4 new typed signals. GameManager has coins variable that resets to 0. All 8 FruitData resources have power-of-2 score values (1, 2, 4, 8, 16, 32, 64, 128).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ScoreManager component with chain tracking and coin economy</name>
  <files>
    scripts/components/score_manager.gd
    scenes/game/game.tscn
  </files>
  <action>
    **ScoreManager (scripts/components/score_manager.gd):** Create new file with `class_name ScoreManager extends Node`.

    Core responsibilities:
    1. **Scoring:** Listen to `EventBus.fruit_merged(old_tier, new_tier, merge_pos)`. Look up base score from FruitData resources using `new_tier` index. If `new_tier >= _fruit_types.size()` (watermelon vanish), award flat 1000 bonus instead (NOT 1000 + tier score -- the bonus replaces the tier score per research pitfall #4).
    2. **Chain tracking:** Maintain `_chain_count: int` that increments on every merge. Use a Timer child node (`$ChainTimer`, one_shot=true, wait_time=1.0) that restarts on each merge. When the timer expires (no merge within 1.0s), emit `EventBus.chain_ended(_chain_count)` if chain_count > 1, then reset chain_count to 0. This timer only detects chain END, not chain membership -- every merge while chain is active counts.
    3. **Chain multiplier:** Use accelerating Fibonacci-like table: `const CHAIN_MULTIPLIERS: Array[int] = [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]`. For chain_count=1, multiplier=1 (no bonus). For chain_count=2, multiplier=2 (x2). Index is `chain_count - 1`, clamped to array bounds. For chains beyond 10, use the last value (89) -- no cap means it stays at the highest defined value.
    4. **Apply multiplier per-merge** (discretion decision): `total_score = base_score * multiplier`. Update `GameManager.score += total_score`. Emit `EventBus.score_awarded.emit(total_score, merge_pos, _chain_count, multiplier)`.
    5. **Coin economy:** After updating score, calculate `var new_coins: int = GameManager.score / COIN_THRESHOLD - _coins_awarded` where `const COIN_THRESHOLD: int = 100`. If new_coins > 0, update `_coins_awarded += new_coins`, `GameManager.coins += new_coins`, emit `EventBus.coins_awarded.emit(new_coins, GameManager.coins)`.
    6. **Score thresholds:** Check against `const SCORE_THRESHOLDS: Array[int] = [500, 1500, 3500, 7000]`. Track `_thresholds_reached: int = 0`. After each score update, while `_thresholds_reached < SCORE_THRESHOLDS.size() and GameManager.score >= SCORE_THRESHOLDS[_thresholds_reached]`, emit `EventBus.score_threshold_reached.emit(SCORE_THRESHOLDS[_thresholds_reached])` and increment `_thresholds_reached`.
    7. **Load fruit types:** Same `_load_fruit_types()` pattern as MergeManager and HUD -- load all 8 .tres paths into `_fruit_types: Array[FruitData]`.
    8. **Group:** Add to group "score_manager" in `_ready()`.

    The ChainTimer should be created in `_ready()` as a child Timer node programmatically (not in .tscn) to keep ScoreManager as a script-only component:
    ```
    var _chain_timer: Timer
    func _ready():
        _chain_timer = Timer.new()
        _chain_timer.one_shot = true
        _chain_timer.wait_time = 1.0
        add_child(_chain_timer)
        _chain_timer.timeout.connect(_on_chain_expired)
    ```

    **game.tscn:** Add a ScoreManager node as a child of the root Game node (after MergeManager, before DropController). The node type is `Node` with the ScoreManager script attached and group "score_manager". Read the existing game.tscn first, then add the ScoreManager entry following the same format pattern as MergeManager.
  </action>
  <verify>
    Verify score_manager.gd exists and contains: class_name ScoreManager, fruit_merged.connect, score_awarded.emit, chain_ended.emit, coins_awarded.emit, score_threshold_reached.emit, CHAIN_MULTIPLIERS array, COIN_THRESHOLD constant, SCORE_THRESHOLDS array.
    Verify game.tscn contains a ScoreManager node with the correct script reference and group.
    Open the project in Godot (or check scene tree) -- ScoreManager should appear as a child of Game.
  </verify>
  <done>
    ScoreManager component exists, is wired into game.tscn, listens to fruit_merged signal, awards exponential points with chain multipliers, tracks coins via score thresholds, and emits all 4 scoring-related signals for Plan 02's UI to consume. Chain timer resets on each merge and fires chain_ended when physics settles.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. All 4 new EventBus signals exist (score_awarded, chain_ended, coins_awarded, score_threshold_reached)
2. GameManager has coins variable that resets properly
3. All 8 FruitData .tres files have power-of-2 score_value
4. ScoreManager is a child node in game.tscn
5. ScoreManager connects to EventBus.fruit_merged and emits score_awarded
6. Chain multiplier table uses accelerating values [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
7. Coin threshold is 100 score per coin
8. Score thresholds [500, 1500, 3500, 7000] emit signals for Phase 5
</verification>

<success_criteria>
- Merging two blueberries awards 2 points (grape score_value=2, multiplier=1)
- Merging two watermelons awards 1000 points (flat bonus)
- Second merge in a cascade awards base_score * 2 (chain multiplier x2)
- GameManager.score accumulates correctly across merges
- GameManager.coins increments by 1 for every 100 cumulative score
- Chain counter resets after 1.0s of no merging
</success_criteria>

<output>
After completion, create `.planning/phases/02-scoring-chain-reactions/02-01-SUMMARY.md`
</output>
