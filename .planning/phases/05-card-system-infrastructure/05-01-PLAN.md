---
phase: 05-card-system-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - resources/card_data/card_data.gd
  - resources/card_data/bouncy_berry.tres
  - resources/card_data/heavy_hitter.tres
  - resources/card_data/wild_fruit.tres
  - resources/card_data/quick_fuse.tres
  - resources/card_data/fruit_frenzy.tres
  - resources/card_data/big_game_hunter.tres
  - resources/card_data/golden_touch.tres
  - resources/card_data/lucky_break.tres
  - resources/card_data/cherry_bomb.tres
  - resources/card_data/pineapple_express.tres
  - scripts/autoloads/card_manager.gd
  - scripts/autoloads/event_bus.gd
  - scripts/autoloads/game_manager.gd
  - scenes/ui/card_slot_display.tscn
  - scenes/ui/card_slot_display.gd
  - project.godot
autonomous: true

must_haves:
  truths:
    - "CardData resource class exists with card_id, card_name, description, rarity enum (COMMON/UNCOMMON/RARE), base_price, and icon fields"
    - "All 10 card .tres files load correctly with unique card_ids and accurate rarity/pricing"
    - "CardManager autoload manages 3-slot inventory (add, remove, has_empty_slot), generates weighted-rarity shop offers, and resets cleanly"
    - "GameManager has SHOPPING and PICKING states that pause the tree"
    - "EventBus has card signals (card_purchased, card_sold, shop_opened, shop_closed, starter_pick_requested, starter_pick_completed, active_cards_changed)"
    - "CardSlotDisplay component renders a card with name, description, rarity-colored border, and optional price tag"
  artifacts:
    - path: "resources/card_data/card_data.gd"
      provides: "CardData Resource class with Rarity enum"
      contains: "class_name CardData"
    - path: "scripts/autoloads/card_manager.gd"
      provides: "Card inventory, shop offer generation, rarity weighting, reset"
      exports: ["reset", "add_card", "remove_card", "has_empty_slot", "generate_shop_offers", "generate_starter_offers", "get_buy_price", "get_sell_price"]
    - path: "scripts/autoloads/event_bus.gd"
      provides: "Card lifecycle signals"
      contains: "signal card_purchased"
    - path: "scripts/autoloads/game_manager.gd"
      provides: "SHOPPING and PICKING states with tree pause"
      contains: "SHOPPING"
    - path: "scenes/ui/card_slot_display.tscn"
      provides: "Reusable card display component"
    - path: "scenes/ui/card_slot_display.gd"
      provides: "display_card() and display_empty() API"
      contains: "func display_card"
  key_links:
    - from: "scripts/autoloads/card_manager.gd"
      to: "resources/card_data/*.tres"
      via: "ResourceLoader loading card pool"
      pattern: "load.*res://resources/card_data"
    - from: "scripts/autoloads/game_manager.gd"
      to: "scripts/autoloads/card_manager.gd"
      via: "reset_game() calls CardManager.reset()"
      pattern: "CardManager\\.reset"
    - from: "scenes/ui/card_slot_display.gd"
      to: "resources/card_data/card_data.gd"
      via: "display_card(card: CardData)"
      pattern: "card\\.card_name"
---

<objective>
Create the card system foundation: CardData resource class, all 10 card definitions as .tres files, the CardManager autoload for inventory/economy/shop-offer generation, GameManager SHOPPING/PICKING states, EventBus card signals, and a reusable CardSlotDisplay UI component.

Purpose: Everything in Phase 5 (shop, starter pick, HUD slots) depends on having card data, a card manager, game states, and a display component. This plan builds the entire data and logic layer so Plans 02 and 03 can focus purely on UI overlays and game flow.

Output: CardData class + 10 .tres resources, CardManager autoload registered in project.godot, extended GameManager and EventBus, reusable card_slot_display scene.
</objective>

<execution_context>
@/home/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/home/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-card-system-infrastructure/05-RESEARCH.md

@resources/fruit_data/fruit_data.gd
@resources/fruit_data/tier_1_blueberry.tres
@scripts/autoloads/event_bus.gd
@scripts/autoloads/game_manager.gd
@project.godot
</context>

<tasks>

<task type="auto">
  <name>Task 1: CardData resource, 10 card .tres files, CardManager autoload, EventBus signals, GameManager states</name>
  <files>
    resources/card_data/card_data.gd
    resources/card_data/bouncy_berry.tres
    resources/card_data/heavy_hitter.tres
    resources/card_data/wild_fruit.tres
    resources/card_data/quick_fuse.tres
    resources/card_data/fruit_frenzy.tres
    resources/card_data/big_game_hunter.tres
    resources/card_data/golden_touch.tres
    resources/card_data/lucky_break.tres
    resources/card_data/cherry_bomb.tres
    resources/card_data/pineapple_express.tres
    scripts/autoloads/card_manager.gd
    scripts/autoloads/event_bus.gd
    scripts/autoloads/game_manager.gd
    project.godot
  </files>
  <action>
    **CardData Resource class** (`resources/card_data/card_data.gd`):
    - Mirror the FruitData pattern exactly (class_name, extends Resource, @export fields).
    - Fields: `card_id: String`, `card_name: String`, `description: String`, `rarity: Rarity` (enum with COMMON=0, UNCOMMON=1, RARE=2), `base_price: int`, `icon: Texture2D` (nullable, no icon needed yet).
    - The Rarity enum must be defined inside CardData (like `enum Rarity { COMMON, UNCOMMON, RARE }`).

    **10 Card .tres files** (all in `resources/card_data/`):
    - Follow the exact .tres format from tier_1_blueberry.tres but with script_class="CardData" and ext_resource pointing to card_data.gd.
    - Card definitions (card_id, card_name, description, rarity int, base_price):
      1. `bouncy_berry.tres`: "bouncy_berry", "Bouncy Berry", "Small fruits (tier 1-3) bounce 50% higher on impact", 0 (COMMON), 8
      2. `quick_fuse.tres`: "quick_fuse", "Quick Fuse", "Merges within 1s of previous merge grant +25% score", 0 (COMMON), 8
      3. `fruit_frenzy.tres`: "fruit_frenzy", "Fruit Frenzy", "+2x score multiplier for chains of 3+", 0 (COMMON), 10
      4. `golden_touch.tres`: "golden_touch", "Golden Touch", "+2 bonus coins per merge", 0 (COMMON), 10
      5. `cherry_bomb.tres`: "cherry_bomb", "Cherry Bomb", "When cherries merge, push nearby fruits outward", 0 (COMMON), 8
      6. `heavy_hitter.tres`: "heavy_hitter", "Heavy Hitter", "Next 3 drops have 2x mass, push harder on contact", 1 (UNCOMMON), 18
      7. `big_game_hunter.tres`: "big_game_hunter", "Big Game Hunter", "+50% score for tier 7+ merges", 1 (UNCOMMON), 20
      8. `lucky_break.tres`: "lucky_break", "Lucky Break", "15% chance any merge drops bonus 5 coins", 1 (UNCOMMON), 16
      9. `pineapple_express.tres`: "pineapple_express", "Pineapple Express", "When pineapple created: +20 coins, +100 score", 1 (UNCOMMON), 18
      10. `wild_fruit.tres`: "wild_fruit", "Wild Fruit", "One random fruit becomes wild (merges with same OR adjacent tier)", 2 (RARE), 30
    - No icon texture needed -- leave the `icon` field unset (Godot serializes null Texture2D as absent).

    **CardManager autoload** (`scripts/autoloads/card_manager.gd`):
    - `extends Node`, no class_name needed (it's an autoload).
    - Constants: `MAX_CARD_SLOTS = 3`, `RARITY_WEIGHTS` array of arrays (4 shop levels: [[0.70, 0.25, 0.05], [0.55, 0.35, 0.10], [0.40, 0.40, 0.20], [0.25, 0.40, 0.35]]), `PRICE_MULTIPLIERS: Array[float] = [1.0, 1.25, 1.5, 2.0]`.
    - State: `active_cards: Array` (size 3, each element is either null or a Dictionary `{card: CardData, purchase_price: int}`), `_card_pool: Array[CardData]` (all 10 cards loaded from .tres), `_shop_level: int = 0`.
    - `_ready()`: call `_load_card_pool()` then `reset()`.
    - `_load_card_pool()`: Load all 10 .tres files from `res://resources/card_data/` using explicit paths (same pattern as ScoreManager._load_fruit_types). Skip card_data.gd. Use `load(path) as CardData`.
    - `reset()`: Clear active_cards to [null, null, null], set _shop_level = 0.
    - `has_empty_slot() -> bool`: return whether any element is null.
    - `add_card(card: CardData, purchase_price: int = 0) -> int`: Find first null slot, set to `{card: card, purchase_price: purchase_price}`, return slot index (-1 if full).
    - `remove_card(slot_index: int) -> CardData`: Remove and return card from slot (set to null), return null if already empty. Return the CardData (not the dictionary).
    - `get_card(slot_index: int) -> CardData`: Return the CardData at slot (or null). Extracts from dictionary.
    - `get_buy_price(card: CardData) -> int`: `int(card.base_price * _get_price_multiplier())`.
    - `get_sell_price(slot_index: int) -> int`: Return `active_cards[slot_index].purchase_price / 2` (integer division). This is 50% of what the player actually paid, per research recommendation.
    - `_get_price_multiplier() -> float`: `PRICE_MULTIPLIERS[mini(_shop_level, PRICE_MULTIPLIERS.size() - 1)]`.
    - `generate_shop_offers(count: int = 3) -> Array[CardData]`: Generate `count` cards using weighted rarity selection at current shop level. Avoid duplicate card_ids within one offer set (re-roll if duplicate). Return Array[CardData].
    - `generate_starter_offers(count: int = 3) -> Array[CardData]`: Same as generate_shop_offers but always uses shop level 0 weights (more common cards for starters). Does not increment shop level.
    - `advance_shop_level()`: Increment `_shop_level` (called by game.gd when opening shop).
    - `_pick_weighted_rarity(weights: Array) -> int`: Cumulative weight selection (10-line function from research).
    - `_pick_random_card_of_rarity(rarity: int) -> CardData`: Filter _card_pool by rarity, pick_random(). Fallback to COMMON if no cards of target rarity.

    **EventBus signals** (add to existing `scripts/autoloads/event_bus.gd`):
    - Add after existing signals:
      ```
      signal starter_pick_requested(offers: Array)
      signal starter_pick_completed(card: CardData)
      signal shop_opened(offers: Array, shop_level: int)
      signal shop_closed()
      signal card_purchased(card: CardData, slot_index: int)
      signal card_sold(card: CardData, slot_index: int, refund: int)
      signal active_cards_changed(cards: Array)
      ```
    - Keep existing signal declarations untouched. CardData type in signal params requires CardData class to be loaded first -- this works because Resources with class_name are globally available.

    **GameManager states** (modify existing `scripts/autoloads/game_manager.gd`):
    - Add `SHOPPING` and `PICKING` to the GameState enum (after PAUSED, before GAME_OVER).
    - Modify `change_state()`:
      - When entering PAUSED, SHOPPING, or PICKING: save `_previous_state` and pause tree. The current code only saves _previous_state for PAUSED -- extend to SHOPPING and PICKING.
      - When leaving PAUSED, SHOPPING, or PICKING: unpause tree. The current code only unpauses for leaving PAUSED -- extend.
      - Keep the emit BEFORE pause pattern (emit game_state_changed before get_tree().paused = true).
    - Modify `reset_game()`: Add `CardManager.reset()` after coins = 0 and before `change_state(GameState.READY)`.

    **Register CardManager autoload** in `project.godot`:
    - Add `CardManager="*res://scripts/autoloads/card_manager.gd"` to the [autoload] section, AFTER GameManager (since CardManager.reset_game references GameManager, and GameManager.reset_game references CardManager -- but autoload order matters for _ready() calls, and CardManager._ready() only loads cards and resets its own state).
  </action>
  <verify>
    - Open project in Godot editor (or verify via file inspection):
      - `resources/card_data/card_data.gd` exists with class_name CardData and Rarity enum
      - All 10 .tres files exist and reference card_data.gd script
      - `scripts/autoloads/card_manager.gd` exists with all listed functions
      - `scripts/autoloads/event_bus.gd` has 7 new card signals
      - `scripts/autoloads/game_manager.gd` has SHOPPING and PICKING in enum, extended change_state logic, CardManager.reset() in reset_game()
      - `project.godot` [autoload] section includes CardManager
    - Verify no syntax errors by checking GDScript structure (matching braces, correct indentation, valid enum references).
  </verify>
  <done>
    CardData class with Rarity enum defines the card schema. 10 .tres card resources exist with correct card_id, name, description, rarity, and base_price. CardManager autoload is registered, loads all 10 cards, manages 3-slot inventory with add/remove/get, generates weighted shop offers avoiding duplicates, calculates buy/sell prices with inflation, and resets cleanly. GameManager has SHOPPING and PICKING states that pause/unpause the tree. EventBus has all 7 card lifecycle signals. GameManager.reset_game() calls CardManager.reset().
  </done>
</task>

<task type="auto">
  <name>Task 2: Reusable CardSlotDisplay UI component</name>
  <files>
    scenes/ui/card_slot_display.tscn
    scenes/ui/card_slot_display.gd
  </files>
  <action>
    **CardSlotDisplay scene** (`scenes/ui/card_slot_display.tscn`):
    - Root node: PanelContainer named "CardSlotDisplay".
    - Set custom_minimum_size to Vector2(200, 120) for a card-sized display.
    - Add a default StyleBoxFlat as the "panel" theme override with:
      - bg_color: Color(0.15, 0.15, 0.2, 0.9) (dark card background)
      - border_width_left/right/top/bottom: 3
      - border_color: Color(0.5, 0.5, 0.5, 1) (default grey, overridden by rarity)
      - corner_radius (all 4): 8
      - content_margin_left/right/top/bottom: 8
    - Child: MarginContainer (for padding inside the panel).
    - Child of MarginContainer: VBoxContainer named "Content" with separation = 4.
    - Children of Content:
      - Label named "CardName": font_size 20, horizontal_alignment CENTER, mouse_filter IGNORE.
      - Label named "Description": font_size 14, horizontal_alignment CENTER, autowrap_mode WORD_SMART, mouse_filter IGNORE, custom_minimum_size.y = 40 (for multi-line descriptions).
      - Label named "PriceLabel": font_size 16, horizontal_alignment CENTER, mouse_filter IGNORE, visible = false (hidden by default, shown in shop context).
    - All mouse_filter on containers set to IGNORE (non-interactive by default; shop/HUD parent handles clicks).

    **CardSlotDisplay script** (`scenes/ui/card_slot_display.gd`):
    - `extends PanelContainer`
    - Constants: `RARITY_COLORS: Dictionary = { CardData.Rarity.COMMON: Color(0.7, 0.7, 0.7), CardData.Rarity.UNCOMMON: Color(0.2, 0.7, 0.3), CardData.Rarity.RARE: Color(0.85, 0.65, 0.1) }` (grey, green, gold).
    - `RARITY_NAMES: Dictionary = { CardData.Rarity.COMMON: "Common", CardData.Rarity.UNCOMMON: "Uncommon", CardData.Rarity.RARE: "Rare" }`.
    - `func display_card(card: CardData, price: int = -1) -> void`:
      - Set $Content/CardName.text = card.card_name
      - Set $Content/Description.text = card.description
      - If price >= 0: show $Content/PriceLabel, set text to "%d coins" % price. Else: hide PriceLabel.
      - Duplicate the panel StyleBoxFlat (get_theme_stylebox("panel").duplicate()), set border_color to RARITY_COLORS[card.rarity], apply via add_theme_stylebox_override("panel", style).
    - `func display_empty() -> void`:
      - Set $Content/CardName.text = "Empty"
      - Set $Content/Description.text = ""
      - Hide PriceLabel.
      - Reset border to default grey: duplicate stylebox, set border_color to Color(0.3, 0.3, 0.3, 0.5), apply override.
    - `func set_sell_mode(sell_price: int) -> void`:
      - Show PriceLabel with text "Sell: %d coins" % sell_price.
      - This is called by the shop to show sell price on owned cards.

    Note: The .tscn file should be hand-constructable. Use sub_resources for the StyleBoxFlat and LabelSettings. Follow the same format as pause_menu.tscn and hud.tscn.
  </action>
  <verify>
    - `scenes/ui/card_slot_display.tscn` exists with PanelContainer root, VBoxContainer with CardName/Description/PriceLabel children.
    - `scenes/ui/card_slot_display.gd` has display_card(), display_empty(), and set_sell_mode() functions.
    - The script references CardData.Rarity enum correctly.
    - StyleBoxFlat has border and corner radius for card appearance.
  </verify>
  <done>
    CardSlotDisplay is a self-contained, reusable PanelContainer scene that renders any CardData with rarity-colored border, name, description, and optional price. It has display_card(), display_empty(), and set_sell_mode() APIs. Ready to be instanced in HUD (Plan 02) and shop/starter-pick overlays (Plans 02/03).
  </done>
</task>

</tasks>

<verification>
- All 10 card .tres files parse correctly (valid Resource format with script_class="CardData")
- CardManager autoload loads without errors (all _card_pool entries populated)
- GameManager.GameState enum has READY, DROPPING, WAITING, PAUSED, SHOPPING, PICKING, GAME_OVER
- EventBus has both original signals (fruit_merged, game_over_triggered, etc.) and new card signals
- CardSlotDisplay can render any CardData with correct rarity border color
- GameManager.reset_game() calls CardManager.reset()
- project.godot has CardManager in [autoload] section
</verification>

<success_criteria>
- 10 CardData .tres files exist with distinct card_ids, correct rarity values (5 Common, 4 Uncommon, 1 Rare), and balanced base_prices
- CardManager registered as autoload, loads all 10 cards, supports add/remove/generate_shop_offers/reset
- GameManager pauses tree for SHOPPING and PICKING states, unpauses when leaving them
- CardSlotDisplay renders cards with grey/green/gold borders for Common/Uncommon/Rare
- Game still launches and plays normally (card system is inert until Plans 02/03 wire it up)
</success_criteria>

<output>
After completion, create `.planning/phases/05-card-system-infrastructure/05-01-SUMMARY.md`
</output>
