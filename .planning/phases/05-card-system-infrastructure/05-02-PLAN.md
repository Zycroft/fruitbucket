---
phase: 05-card-system-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - scenes/ui/card_shop.tscn
  - scenes/ui/card_shop.gd
  - scenes/ui/hud.tscn
  - scenes/ui/hud.gd
  - scenes/game/game.tscn
  - scenes/game/game.gd
autonomous: true

must_haves:
  truths:
    - "Score threshold pauses the game and opens the card shop overlay"
    - "Shop displays 3 card offers with name, description, rarity border, and inflated price"
    - "Player can buy a card if they have enough coins and an open slot"
    - "Player can sell an owned card from their slots for 50% of purchase price"
    - "Player can skip the shop to resume play"
    - "HUD shows 3 card slots that update when cards are purchased or sold"
    - "Coins update in HUD when spending or receiving refund"
    - "Shop prices increase in later shops (price multiplier per shop level)"
    - "Rare cards appear more frequently in later shops"
  artifacts:
    - path: "scenes/ui/card_shop.tscn"
      provides: "Card shop CanvasLayer overlay"
      contains: "CanvasLayer"
    - path: "scenes/ui/card_shop.gd"
      provides: "Buy/sell/skip logic, shop UI management"
      contains: "func _on_buy_pressed"
    - path: "scenes/ui/hud.tscn"
      provides: "HUD with 3 card slots"
      contains: "CardSlots"
    - path: "scenes/ui/hud.gd"
      provides: "Card slot display updates on purchase/sell signals"
      contains: "card_purchased"
    - path: "scenes/game/game.tscn"
      provides: "Game scene with CardShop node"
      contains: "CardShop"
    - path: "scenes/game/game.gd"
      provides: "Score threshold -> shop open flow"
      contains: "score_threshold_reached"
  key_links:
    - from: "scenes/game/game.gd"
      to: "scripts/autoloads/card_manager.gd"
      via: "generate_shop_offers() on threshold"
      pattern: "CardManager\\.generate_shop_offers"
    - from: "scenes/ui/card_shop.gd"
      to: "scripts/autoloads/game_manager.gd"
      via: "coins check and state transitions"
      pattern: "GameManager\\.coins"
    - from: "scenes/ui/card_shop.gd"
      to: "scripts/autoloads/event_bus.gd"
      via: "card_purchased/card_sold/shop_closed signals"
      pattern: "EventBus\\.card_purchased\\.emit"
    - from: "scenes/ui/hud.gd"
      to: "scripts/autoloads/event_bus.gd"
      via: "listens to card_purchased, card_sold, active_cards_changed"
      pattern: "EventBus\\.card_purchased\\.connect"
---

<objective>
Build the card shop overlay and integrate card slots into the HUD. When score thresholds are crossed, the game pauses and opens a shop where the player can buy cards (if affordable and slots available), sell owned cards for 50% refund, or skip. The HUD displays 3 card slots that update in real-time as cards are purchased or sold.

Purpose: This delivers the core card economy loop -- earning coins through merges, spending them in the shop, and seeing owned cards in the HUD. Requirements CARD-01, CARD-02, CARD-03, CARD-04, CARD-06, CARD-07, CARD-08, CARD-11.

Output: Card shop overlay scene, modified HUD with card slots, game.gd threshold-to-shop wiring.
</objective>

<execution_context>
@/home/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/home/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-card-system-infrastructure/05-RESEARCH.md
@.planning/phases/05-card-system-infrastructure/05-01-SUMMARY.md

@scenes/ui/pause_menu.tscn
@scenes/ui/pause_menu.gd
@scenes/ui/hud.tscn
@scenes/ui/hud.gd
@scenes/ui/card_slot_display.tscn
@scenes/ui/card_slot_display.gd
@scenes/game/game.tscn
@scenes/game/game.gd
@scripts/autoloads/event_bus.gd
@scripts/autoloads/game_manager.gd
@scripts/autoloads/card_manager.gd
</context>

<tasks>

<task type="auto">
  <name>Task 1: Card shop overlay with buy/sell/skip</name>
  <files>
    scenes/ui/card_shop.tscn
    scenes/ui/card_shop.gd
  </files>
  <action>
    **CardShop scene** (`scenes/ui/card_shop.tscn`):
    - Root: CanvasLayer named "CardShop", layer = 11 (above PauseMenu at 10), process_mode = 3 (ALWAYS).
    - Start visible = false (shown when shop_opened signal received).
    - Child structure following PauseMenu pattern exactly:
      ```
      CardShop (CanvasLayer, layer=11, process_mode=ALWAYS)
        Overlay (ColorRect, anchors_preset=15 full rect, color=Color(0,0,0,0.6), mouse_filter=0 STOP)
          ShopContainer (VBoxContainer, centered like PauseMenu's MenuContainer)
            - anchors_preset=8 (center), offsets to create ~600x900 centered area
            - offset_left=-300, offset_top=-450, offset_right=300, offset_bottom=450
            - mouse_filter=2 (IGNORE)
            - theme_override_constants/separation = 16
            TitleLabel (Label, "CARD SHOP", font_size=48, center aligned, mouse_filter=2)
            CoinLabel (Label, "Coins: 0", font_size=28, center aligned, mouse_filter=2)
            OffersLabel (Label, "Available Cards:", font_size=20, center aligned, mouse_filter=2)
            OffersContainer (VBoxContainer, separation=12, mouse_filter=2)
              -- Offer slots populated dynamically
            Divider (HSeparator)
            YourCardsLabel (Label, "Your Cards (tap to sell):", font_size=20, center aligned, mouse_filter=2)
            SlotsContainer (HBoxContainer, separation=12, alignment=CENTER, mouse_filter=2)
              -- 3 CardSlotDisplay instances populated dynamically
            SkipButton (Button, "Continue", custom_minimum_size=Vector2(200,60), font_size=24, center aligned)
      ```

    **CardShop script** (`scenes/ui/card_shop.gd`):
    - `extends CanvasLayer`
    - Preload: `var _card_slot_scene: PackedScene = preload("res://scenes/ui/card_slot_display.tscn")`
    - State: `var _current_offers: Array[CardData] = []`, `var _offer_nodes: Array = []`, `var _slot_nodes: Array = []`.
    - `_ready()`:
      - `process_mode = Node.PROCESS_MODE_ALWAYS`
      - `visible = false`
      - Connect `EventBus.shop_opened.connect(_on_shop_opened)`
      - Connect `$Overlay/ShopContainer/SkipButton.pressed.connect(_on_skip_pressed)`
      - Create 3 CardSlotDisplay instances in SlotsContainer for the player's card slots. Store in `_slot_nodes`. Connect each slot's `gui_input` signal to `_on_slot_clicked.bind(i)` for sell interaction.
    - `_on_shop_opened(offers: Array, shop_level: int)`:
      - Store offers in `_current_offers`.
      - Update CoinLabel: "Coins: %d" % GameManager.coins.
      - Clear and rebuild OffersContainer:
        - For each offer card, create a CardSlotDisplay instance, call `display_card(card, CardManager.get_buy_price(card))`. Add a Button child "Buy" to each offer container (or wrap in HBoxContainer with slot + buy button). Connect buy button to `_on_buy_pressed.bind(i)`.
        - Implementation detail: For each offer, create an HBoxContainer. Add a CardSlotDisplay (display_card with price) and a Button ("Buy", custom_minimum_size Vector2(80,50)). Connect the button's pressed signal.
      - Update the 3 player slot displays by calling `_refresh_slots()`.
      - `visible = true`
    - `_refresh_slots()`:
      - For each of 3 slots: if CardManager.get_card(i) is not null, call `_slot_nodes[i].display_card(CardManager.get_card(i))` and `_slot_nodes[i].set_sell_mode(CardManager.get_sell_price(i))`. Else call `_slot_nodes[i].display_empty()`.
      - Update CoinLabel text.
    - `_on_buy_pressed(offer_index: int)`:
      - Get card from `_current_offers[offer_index]`.
      - Calculate price: `CardManager.get_buy_price(card)`.
      - Guard: if `GameManager.coins < price`, flash the CoinLabel red briefly (tween modulate to red and back), return.
      - Guard: if `not CardManager.has_empty_slot()`, flash YourCardsLabel, return.
      - Deduct coins: `GameManager.coins -= price`.
      - Add card: `var slot: int = CardManager.add_card(card, price)`.
      - Emit: `EventBus.card_purchased.emit(card, slot)`.
      - Emit: `EventBus.active_cards_changed.emit(CardManager.active_cards)`.
      - Disable the buy button for this offer (grey out, disabled = true) so the card cannot be bought twice.
      - Call `_refresh_slots()`.
    - `_on_slot_clicked(slot_index: int, event: InputEvent)`:
      - Guard: only respond to InputEventMouseButton pressed events (left click or touch).
      - Guard: if CardManager.get_card(slot_index) == null, return.
      - Calculate refund: `CardManager.get_sell_price(slot_index)`.
      - Remove card: `var card: CardData = CardManager.remove_card(slot_index)`.
      - Refund: `GameManager.coins += refund`.
      - Emit: `EventBus.card_sold.emit(card, slot_index, refund)`.
      - Emit: `EventBus.active_cards_changed.emit(CardManager.active_cards)`.
      - Call `_refresh_slots()`.
    - `_on_skip_pressed()`:
      - `visible = false`
      - Clear offer nodes (queue_free dynamic children in OffersContainer).
      - Emit: `EventBus.shop_closed.emit()`.
    - Cleanup: When hiding, always clean up dynamic OffersContainer children to prevent memory leaks.

    **Key patterns from PauseMenu to follow:**
    - CanvasLayer with process_mode ALWAYS
    - Overlay ColorRect with mouse_filter=STOP (value 0) blocks click-through
    - VBoxContainer with mouse_filter=IGNORE (value 2) for layout
    - Buttons with mouse_filter=STOP (value 0) for interaction
  </action>
  <verify>
    - `scenes/ui/card_shop.tscn` exists with CanvasLayer root, layer 11, process_mode ALWAYS.
    - `scenes/ui/card_shop.gd` has _on_shop_opened, _on_buy_pressed, _on_slot_clicked, _on_skip_pressed functions.
    - Overlay ColorRect has mouse_filter=0 (STOP).
    - Script connects to EventBus.shop_opened signal.
    - Buy flow: checks coins and empty slots, deducts coins, adds card, emits signals.
    - Sell flow: removes card, refunds coins, emits signals.
    - Skip flow: hides overlay, emits shop_closed.
  </verify>
  <done>
    Card shop overlay appears on layer 11 with dark background blocking game input. Shows 3 card offers with rarity borders and inflated prices, 3 player card slots with sell prices, and a skip button. Buy validates coins/slots, sell refunds 50% of purchase price, skip closes shop. All transactions emit EventBus signals for HUD sync.
  </done>
</task>

<task type="auto">
  <name>Task 2: HUD card slots and game.gd threshold-to-shop wiring</name>
  <files>
    scenes/ui/hud.tscn
    scenes/ui/hud.gd
    scenes/game/game.tscn
    scenes/game/game.gd
  </files>
  <action>
    **HUD modifications** (`scenes/ui/hud.tscn` and `scenes/ui/hud.gd`):

    In `hud.tscn`:
    - Add an HBoxContainer named "CardSlots" at the bottom of the HUD area.
    - Position: offset_left=90, offset_top=1750, offset_right=990, offset_bottom=1880 (bottom of 1080x1920 viewport, above any safe area).
    - theme_override_constants/separation = 12, alignment = CENTER.
    - mouse_filter = 2 (IGNORE -- card slots in HUD are display-only, not interactive).
    - This container will hold 3 CardSlotDisplay instances created in code.

    In `hud.gd`:
    - Add preload: `var _card_slot_scene: PackedScene = preload("res://scenes/ui/card_slot_display.tscn")`
    - Add state: `var _card_slot_nodes: Array = []`
    - In `_ready()`, after existing signal connections, add:
      - `EventBus.card_purchased.connect(_on_card_purchased)`
      - `EventBus.card_sold.connect(_on_card_sold)`
      - `EventBus.active_cards_changed.connect(_on_active_cards_changed)`
      - Create 3 CardSlotDisplay instances, add as children of $CardSlots, call display_empty() on each, store in `_card_slot_nodes`.
      - Set each card slot's custom_minimum_size to Vector2(280, 100) so they fit the HUD width (3 * 280 + 2 * 12 gap = 864, fits in 900px width).
    - `_on_card_purchased(card: CardData, slot_index: int)`:
      - `_card_slot_nodes[slot_index].display_card(card)`
      - Update coin display: `$CoinLabel.text = "Coins: %d" % GameManager.coins`
    - `_on_card_sold(_card: CardData, slot_index: int, _refund: int)`:
      - `_card_slot_nodes[slot_index].display_empty()`
      - Update coin display: `$CoinLabel.text = "Coins: %d" % GameManager.coins`
    - `_on_active_cards_changed(cards: Array)`:
      - Refresh all 3 slots: for each i, if cards[i] != null, display_card(cards[i].card) else display_empty(). This handles bulk updates (e.g., after reset).
    - Modify `_on_game_state_changed()`: hide PauseButton during SHOPPING and PICKING states too (not just PAUSED). Add checks:
      ```
      elif new_state == GameManager.GameState.SHOPPING \
              or new_state == GameManager.GameState.PICKING:
          $PauseButton.visible = false
      ```

    **Game scene modifications** (`scenes/game/game.tscn`):
    - Add CardShop as a child of Game node: instance of `res://scenes/ui/card_shop.tscn`.
    - Place it after PauseMenu in the tree (last child), since it's layer 11 (above PauseMenu layer 10).

    **Game script modifications** (`scenes/game/game.gd`):
    - Add signal connections in `_ready()`:
      - `EventBus.score_threshold_reached.connect(_on_score_threshold)`
      - `EventBus.shop_closed.connect(_on_shop_closed)`
    - Add `_on_score_threshold(threshold: int)`:
      - Guard: only open shop if current state is DROPPING or WAITING (not if already SHOPPING, PAUSED, PICKING, or GAME_OVER).
      - Generate offers: `var offers: Array = CardManager.generate_shop_offers()`
      - Advance shop level: `CardManager.advance_shop_level()`
      - Change state: `GameManager.change_state(GameManager.GameState.SHOPPING)`
      - Emit: `EventBus.shop_opened.emit(offers, CardManager._shop_level)`
    - Add `_on_shop_closed()`:
      - `GameManager.change_state(GameManager.GameState.DROPPING)`
    - Keep existing _ready() flow (READY -> await 0.3s -> DROPPING) unchanged for now. The starter pick (Plan 03) will modify this.
  </action>
  <verify>
    - `scenes/ui/hud.tscn` has CardSlots HBoxContainer node.
    - `scenes/ui/hud.gd` creates 3 CardSlotDisplay instances, connects to card_purchased/card_sold/active_cards_changed signals.
    - `scenes/game/game.tscn` has CardShop instance as child of Game.
    - `scenes/game/game.gd` connects to score_threshold_reached and shop_closed, opens shop on threshold.
    - Game launches without errors. Existing gameplay (drop, merge, score) still works.
    - When score crosses 500, shop overlay appears with card offers.
    - Buying a card deducts coins and shows card in HUD slot.
    - Selling a card refunds coins and clears HUD slot.
    - Skipping closes shop and resumes gameplay.
  </verify>
  <done>
    HUD displays 3 card slots at the bottom of the screen that update when cards are purchased or sold. Game.gd listens for score_threshold_reached and opens the card shop with generated offers. The full buy/sell/skip loop works: threshold -> pause -> shop -> buy/sell/skip -> resume. Coin display updates on all transactions. PauseButton hides during SHOPPING state.
  </done>
</task>

</tasks>

<verification>
- Score reaches 500 -> game pauses, shop overlay appears on layer 11 with dark background
- Shop shows 3 cards with rarity-colored borders and prices (inflated by shop level multiplier)
- Player can buy a card: coins deducted, card appears in HUD slot, buy button disabled
- Player cannot buy if insufficient coins (visual flash feedback) or no empty slots
- Player can tap an owned card in the shop to sell it: card removed, 50% refund, HUD slot cleared
- Player taps "Continue" to close shop and resume gameplay
- Score reaches 1500 -> second shop opens with higher prices (1.25x multiplier) and more uncommon/rare cards
- HUD card slots show correct cards with rarity borders throughout gameplay
- Coin display accurate after all buy/sell transactions
- Game still functions normally between shop visits (drop, merge, score, chain reactions)
</verification>

<success_criteria>
- Card shop overlay fully functional with buy, sell, and skip flows
- HUD card slots render active cards with rarity-colored borders
- Score thresholds at 500, 1500, 3500, 7000 each trigger one shop visit
- Shop prices increase per shop level (1.0x, 1.25x, 1.5x, 2.0x)
- Rarity weights shift toward rare cards in later shops
- All coin transactions (buy/sell) correctly update GameManager.coins and HUD display
- Tree pauses during SHOPPING (fruits frozen, no input leak)
</success_criteria>

<output>
After completion, create `.planning/phases/05-card-system-infrastructure/05-02-SUMMARY.md`
</output>
