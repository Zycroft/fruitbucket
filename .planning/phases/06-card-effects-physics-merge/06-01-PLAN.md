---
phase: 06-card-effects-physics-merge
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/components/card_effect_system.gd
  - scenes/fruit/fruit.gd
  - scripts/autoloads/event_bus.gd
  - scenes/game/game.tscn
  - resources/shaders/rainbow_outline.gdshader
autonomous: true

must_haves:
  truths:
    - "Bouncy Berry makes tier 0-2 fruits bounce visibly higher on impact"
    - "Bouncy Berry applies retroactively to existing fruits when purchased"
    - "Cherry Bomb creates an outward blast pushing nearby fruits when cherries (tier 2) merge"
    - "Cherry Bomb blast produces a visible shockwave ring expanding from the merge point"
    - "Duplicate Bouncy Berry or Cherry Bomb cards stack linearly (2x effect with 2 cards)"
    - "CardEffectSystem resets cleanly on scene reload (no state leak between runs)"
  artifacts:
    - path: "scripts/components/card_effect_system.gd"
      provides: "Central card effect processor with Bouncy Berry and Cherry Bomb logic"
      contains: "_count_active"
    - path: "resources/shaders/rainbow_outline.gdshader"
      provides: "Rainbow cycling outline shader for Wild Fruit (Plan 02 uses it)"
      contains: "shader_type canvas_item"
    - path: "scenes/fruit/fruit.gd"
      provides: "Fruit with is_wild flag, is_heavy flag, _can_merge_with() method"
      contains: "_can_merge_with"
    - path: "scripts/autoloads/event_bus.gd"
      provides: "New signals for card effect communication"
      contains: "heavy_hitter_charges_changed"
  key_links:
    - from: "scripts/components/card_effect_system.gd"
      to: "EventBus.fruit_merged"
      via: "signal connection in _ready()"
      pattern: "fruit_merged\\.connect"
    - from: "scripts/components/card_effect_system.gd"
      to: "CardManager.active_cards"
      via: "_count_active() reads active cards"
      pattern: "CardManager\\.active_cards"
    - from: "scenes/game/game.tscn"
      to: "scripts/components/card_effect_system.gd"
      via: "CardEffectSystem node in scene tree"
      pattern: "card_effect_system"
---

<objective>
Create the CardEffectSystem component and implement Bouncy Berry + Cherry Bomb effects. These are the two "reactive" effects: Bouncy Berry modifies physics properties on fruits, Cherry Bomb fires impulses on merge events. Also add fruit.gd infrastructure (flags, merge check method) and the rainbow shader needed by Plan 02.

Purpose: Establishes the card effect runtime system and proves two effects work end-to-end, from card ownership detection through physics modification to visible gameplay impact.
Output: CardEffectSystem node in game scene, Bouncy Berry bounce modification, Cherry Bomb blast with shockwave visual.
</objective>

<execution_context>
@/home/zycroft/.claude/get-shit-done/workflows/execute-plan.md
@/home/zycroft/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-card-effects-physics-merge/06-CONTEXT.md
@.planning/phases/06-card-effects-physics-merge/06-RESEARCH.md
@scenes/fruit/fruit.gd
@scripts/components/merge_manager.gd
@scripts/autoloads/card_manager.gd
@scripts/autoloads/event_bus.gd
@scenes/game/game.tscn
@resources/fruit_physics.tres
</context>

<tasks>

<task type="auto">
  <name>Task 1: CardEffectSystem scaffold + fruit.gd infrastructure + EventBus signals + rainbow shader</name>
  <files>
    scripts/components/card_effect_system.gd
    scenes/fruit/fruit.gd
    scripts/autoloads/event_bus.gd
    scenes/game/game.tscn
    resources/shaders/rainbow_outline.gdshader
  </files>
  <action>
Create the core infrastructure for all 4 card effects. This task builds the skeleton; Task 2 fills in effect logic.

**1. EventBus signals** (event_bus.gd) -- Add these new signals:
- `signal heavy_hitter_charges_changed(charges: int, max_charges: int)` -- for HUD charge display (Plan 02)
- `signal wild_fruit_marked(fruit: Fruit)` -- when a fruit becomes wild
- `signal wild_fruit_unmarked(fruit: Fruit)` -- when a wild fruit merges/is removed
- `signal cherry_bomb_triggered(position: Vector2)` -- for visual feedback coordination

**2. fruit.gd modifications** -- Add to the class variables:
- `var is_wild: bool = false` -- wild fruit flag for merge rule extension
- `var is_heavy: bool = false` -- heavy hitter flag for visual distinction

Replace the tier equality check in `_on_body_entered()`:
- Remove: `if body.fruit_data.tier != fruit_data.tier: return`
- Replace with: `if not _can_merge_with(body): return`

Add new method `_can_merge_with(other: Fruit) -> bool`:
- If `fruit_data.tier == other.fruit_data.tier`: return true (standard merge)
- If `is_wild or other.is_wild`: return `abs(fruit_data.tier - other.fruit_data.tier) <= 1` (adjacent tier merge)
- Otherwise: return false

**3. CardEffectSystem** (scripts/components/card_effect_system.gd) -- Create new file:
- `class_name CardEffectSystem extends Node`
- In `_ready()`: add to group "card_effect_system", connect signals:
  - `EventBus.fruit_merged.connect(_on_fruit_merged)`
  - `EventBus.fruit_dropped.connect(_on_fruit_dropped)`
  - `EventBus.card_purchased.connect(_on_card_changed)`
  - `EventBus.card_sold.connect(_on_card_removed)`
- Helper: `_count_active(card_id: String) -> int` -- iterate CardManager.active_cards, count non-null entries matching card_id
- Helper: `_get_fruit_container() -> Node` -- `get_tree().get_first_node_in_group("fruit_container")`
- Stub methods for effects (filled in Task 2):
  - `_on_fruit_merged(old_tier: int, new_tier: int, merge_pos: Vector2) -> void`
  - `_on_fruit_dropped(tier: int, pos: Vector2) -> void`
  - `_on_card_changed(_card: CardData, _slot_index: int) -> void` -- calls `_apply_bouncy_berry_all()` to retroactively apply
  - `_on_card_removed(_card: CardData, _slot_index: int, _refund: int) -> void` -- calls `_apply_bouncy_berry_all()` to revert/recalculate

**4. Rainbow outline shader** (resources/shaders/rainbow_outline.gdshader) -- Create directory `resources/shaders/` if needed. Create the shader file:
```glsl
shader_type canvas_item;

uniform float line_scale : hint_range(0, 20) = 4.0;
uniform float frequency : hint_range(0.0, 2.0) = 0.8;
uniform float light_offset : hint_range(0.0, 1.0) = 0.5;

void fragment() {
    vec2 size = TEXTURE_PIXEL_SIZE * line_scale;

    float outline = texture(TEXTURE, UV + vec2(-size.x, 0)).a;
    outline += texture(TEXTURE, UV + vec2(0, size.y)).a;
    outline += texture(TEXTURE, UV + vec2(size.x, 0)).a;
    outline += texture(TEXTURE, UV + vec2(0, -size.y)).a;
    outline += texture(TEXTURE, UV + vec2(-size.x, size.y)).a;
    outline += texture(TEXTURE, UV + vec2(size.x, size.y)).a;
    outline += texture(TEXTURE, UV + vec2(-size.x, -size.y)).a;
    outline += texture(TEXTURE, UV + vec2(size.x, -size.y)).a;
    outline = min(outline, 1.0);

    vec4 rainbow = vec4(
        light_offset + sin(2.0 * 3.14159 * frequency * TIME),
        light_offset + sin(2.0 * 3.14159 * frequency * TIME + radians(120.0)),
        light_offset + sin(2.0 * 3.14159 * frequency * TIME + radians(240.0)),
        1.0
    );

    vec4 color = texture(TEXTURE, UV);
    COLOR = mix(color, rainbow, outline - color.a);
}
```
Use `line_scale = 4.0` (higher than research's 3.0) to ensure visibility on small fruits. No `hint_color` (deprecated in Godot 4).

**5. game.tscn** -- Add CardEffectSystem node after MergeFeedback:
- Add ext_resource for `scripts/components/card_effect_system.gd`
- Add node: `[node name="CardEffectSystem" type="Node" parent="." groups=["card_effect_system"]]` with script reference
  </action>
  <verify>
Open the project in Godot editor. Verify:
1. game.tscn loads without errors (CardEffectSystem node visible in scene tree)
2. No GDScript parse errors in fruit.gd, card_effect_system.gd, event_bus.gd
3. fruit.gd _can_merge_with() method exists and _on_body_entered uses it
  </verify>
  <done>
CardEffectSystem node exists in game scene tree. fruit.gd has is_wild/is_heavy flags and _can_merge_with() method. EventBus has 4 new card effect signals. Rainbow shader file exists at resources/shaders/rainbow_outline.gdshader. No parse errors in any modified file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bouncy Berry effect + Cherry Bomb effect with shockwave</name>
  <files>
    scripts/components/card_effect_system.gd
  </files>
  <action>
Implement the two reactive card effects in CardEffectSystem. Both are event-driven (no per-frame processing).

**1. Bouncy Berry effect:**
- Named constant: `const BOUNCY_BERRY_BOUNCE_BONUS: float = 0.5` (50% bounce increase per card per research)
- Named constant: `const BOUNCY_BASE_BOUNCE: float = 0.15` (matches fruit_physics.tres)
- Named constant: `const BOUNCY_BASE_FRICTION: float = 0.6`
- Named constant: `const BOUNCY_MAX_TIER: int = 2` (affects tiers 0, 1, 2 -- Blueberry, Grape, Cherry)

Method `_apply_bouncy_berry_all() -> void`:
- Get stack_count via `_count_active("bouncy_berry")`
- Iterate `_get_fruit_container().get_children()`
- For each valid Fruit child that is not merging: call `_apply_bouncy_to_fruit(fruit, stack_count)`

Method `_apply_bouncy_to_fruit(fruit: Fruit, stack_count: int) -> void`:
- If `fruit.fruit_data.tier > BOUNCY_MAX_TIER`: restore default material and return
  - Restore: `fruit.physics_material_override = _default_physics_material` (preload the shared material to restore non-bouncy fruits)
- If `stack_count <= 0`: restore default material and return
- Create NEW `PhysicsMaterial.new()`
- Set `mat.friction = BOUNCY_BASE_FRICTION`
- Set `mat.bounce = BOUNCY_BASE_BOUNCE + (BOUNCY_BERRY_BOUNCE_BONUS * stack_count)` (ALWAYS calculate from base, never current)
- Set `fruit.physics_material_override = mat`
- Visual: `fruit.get_node("Sprite2D").modulate = fruit.fruit_data.color.lightened(0.15 * stack_count)` for subtle persistent glow

Preload: `var _default_physics_material: PhysicsMaterial = preload("res://resources/fruit_physics.tres")`

Hook into `_on_card_changed()`: call `_apply_bouncy_berry_all()` (retroactive on purchase)
Hook into `_on_card_removed()`: call `_apply_bouncy_berry_all()` (recalculate on sell -- revert if no more Bouncy Berry)

Hook new fruit spawns: In `_on_fruit_merged()`, after a brief deferred call (to let MergeManager spawn the new fruit), apply bouncy berry to new fruit. Use `call_deferred("_apply_bouncy_berry_all")` inside _on_fruit_merged. This catches newly spawned merge results.

Also apply on `_on_fruit_dropped()`: apply bouncy berry to the just-dropped fruit (it transitions from frozen to physics). Use `call_deferred("_apply_bouncy_berry_all")`.

**2. Cherry Bomb effect:**
- Named constant: `const CHERRY_TIER: int = 2` (cherry is tier index 2 in code, per tier_3_cherry.tres)
- Named constant: `const CHERRY_BOMB_RADIUS: float = 200.0` (blast radius in pixels)
- Named constant: `const CHERRY_BOMB_FORCE: float = 800.0` (base blast force, scales with stack count)

In `_on_fruit_merged()`:
- Check: `if _count_active("cherry_bomb") > 0 and old_tier == CHERRY_TIER:`
- Call `_apply_cherry_bomb(merge_pos, _count_active("cherry_bomb"))`

Method `_apply_cherry_bomb(merge_pos: Vector2, stack_count: int) -> void`:
- `var blast_force: float = CHERRY_BOMB_FORCE * stack_count`
- Iterate `_get_fruit_container().get_children()`
- For each child: skip if not Fruit, not is_instance_valid, merging, is_dropping, or freeze
- Calculate direction = `child.global_position - merge_pos`
- Calculate distance = `direction.length()`
- Skip if distance > CHERRY_BOMB_RADIUS or distance < 1.0
- Calculate strength with linear falloff: `blast_force * (1.0 - distance / CHERRY_BOMB_RADIUS)`
- Apply: `child.apply_central_impulse(direction.normalized() * strength)`
- After loop: `_spawn_shockwave(merge_pos)`
- Emit: `EventBus.cherry_bomb_triggered.emit(merge_pos)`

Method `_spawn_shockwave(pos: Vector2) -> void`:
- Create a shockwave ring using a Line2D drawn as a circle (no separate .tscn needed).
- Create a new Node2D, add it to effects_container (group "effects_container", fallback to self).
- Set its global_position to pos.
- Add a child Line2D with ~32 points forming a circle of radius 1.0.
- Set the Line2D properties: width = 3.0, default_color = Color(1.0, 0.6, 0.2, 0.9) (orange-ish).
- Create a tween:
  - Tween the Node2D scale from Vector2(1, 1) to Vector2(CHERRY_BOMB_RADIUS, CHERRY_BOMB_RADIUS) over 0.3s with EASE_OUT.
  - Parallel tween the Line2D modulate alpha from 0.9 to 0.0 over 0.3s.
  - On tween finished: queue_free the Node2D.
- This creates an expanding, fading ring visual.

**3. _on_fruit_merged dispatch:**
```gdscript
func _on_fruit_merged(old_tier: int, new_tier: int, merge_pos: Vector2) -> void:
    # Cherry Bomb: explode on cherry merge
    var cherry_count: int = _count_active("cherry_bomb")
    if cherry_count > 0 and old_tier == CHERRY_TIER:
        _apply_cherry_bomb(merge_pos, cherry_count)
    # Bouncy Berry: apply to newly spawned merge result
    if _count_active("bouncy_berry") > 0:
        call_deferred("_apply_bouncy_berry_all")
```
  </action>
  <verify>
Run the game. Test:
1. Pick/buy Bouncy Berry card -> drop tier 0-2 fruits -> observe visibly higher bounce than default (compare with a run without Bouncy Berry)
2. Drop several fruits, then buy Bouncy Berry -> existing tier 0-2 fruits should retroactively get bouncier on their next collision
3. Sell Bouncy Berry -> bounce returns to normal for tier 0-2 fruits
4. Pick/buy Cherry Bomb card -> drop two cherries (red, tier 3 display) -> when they merge, nearby fruits get pushed outward and an orange expanding ring appears at the merge point
5. Verify no crash on watermelon vanish, no crash when cherry bomb fires with 0 nearby fruits
6. Verify game starts clean after restart (no lingering effects from previous run)
  </verify>
  <done>
Bouncy Berry modifies tier 0-2 fruit bounce retroactively with linear stacking. Cherry Bomb fires radial impulse on cherry merges with visible shockwave ring. Both effects scale with duplicate card count. No per-frame processing. Clean reset on scene reload.
  </done>
</task>

</tasks>

<verification>
1. Run the game, pick Bouncy Berry as starter card. Drop blueberries and cherries -- they should bounce visibly higher than grapes (tier 1) or strawberries (tier 3+).
2. Pick Cherry Bomb as starter card. Drop cherries to create cherry merges -- observe explosion pushing nearby fruits and orange expanding ring.
3. Restart the game -- no effects should persist from the previous run.
4. The fruit.gd _can_merge_with() method should not affect normal same-tier merges (they work as before).
</verification>

<success_criteria>
- CardEffectSystem node exists in game.tscn scene tree and loads without errors
- Bouncy Berry increases bounce for tier 0-2 fruits proportionally (base 0.15 -> 0.65 with one card)
- Bouncy Berry applies retroactively to existing fruits on card purchase
- Cherry Bomb triggers radial impulse on cherry (tier 2) merges, pushing nearby fruits
- Cherry Bomb produces a visible expanding shockwave ring at merge position
- Duplicate cards produce linearly stronger effects
- No GDScript parse errors, no runtime crashes
- Game reset clears all effect state cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-card-effects-physics-merge/06-01-SUMMARY.md`
</output>
